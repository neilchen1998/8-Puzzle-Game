# 8 Puzzle Game

## Summary

8 Puzzle problem is a simple version of [15 Puzzle problem](https://en.wikipedia.org/wiki/15_puzzle).
This project offers a pretty graphic user interface, allowing the players an engaging way to solve the scrambled title puzzle.

## Requirements

The requirements are:

- CMake 3.14 or better; 4.0+ highly recommended
- A C++23 compatible compiler ([gcc](https://gcc.gnu.org/) or [llvm](https://llvm.org/))
- Git
- Raylib (will be downloaded if not present)
- Slidr (will be downloaded if not present)
- Conda/Miniconda (optional, highly recommended)
- Doxygen (optional, highly recommended)

## Instructions

To configure:

```bash
cmake -S . -B build
```

Add `--toolchain=./<your_toolchain_file>.toolchain` if you want to use your own toolchain.

Add `-GNinja` if you have Ninja.

To build:

```bash
cmake --build build
```

To launch the app:

```bash
./build/apps/app
```

##



## Notes

### `std::generate` vs. For Loop

`std::generate` was introduced in C++17 as a way to assign elements in range $[first, last)$ with a value generated by a policy (usually a lambda function). This method is used to generate confetti.
A comparison is done to compare the speed to initialize 2,000 elements of **confetti** between using `std::generate` and a for loop.

Here is the result:

|               ns/op |                op/s |    err% |     total | Constructors    |
|--------------------:|--------------------:|--------:|----------:|:-------------   |
|          146,230.71 |            6,838.51 |    0.8% |      0.89 | `For Loop`      |
|          139,168.11 |            7,185.55 |    0.5% |      0.83 | `std::generate` |

As the table suggests, using `std::generate` is faster than a traditional for loop.

### Aggregate and Explicit Initialization

An aggregate is a class-type that has no user-defined constructor.
Such as this one:

```cpp
struct Vector
{
    int x;
    int y;
    std::string name;
};
```

Before C++20, one can only initialize an aggregate with the same order listed in the aggregate.
In this case, it is okay to do:

```cpp
Vector v {2, 3, "a"};
```

But it is illegal if you only want to initialize *y* without initializing *x*.
And it is also illegal to initialize the member element in a random order.

Since C++20, one can initialize elements explicitly.
So this becomes legal and it is clearer for others to read:

```cpp
Vector v {.y = 14, .name = "b"};
```

The value of *x* will be 0 (since no value is provided, 0 is the default value), *y* will be 14, and *name* will be *b*.

### Check if Content is Available

When using *FetchContent*, CMake will download the content even if it is install on the machine already.
In order to prevent this but also make sure the machine has the minimium version, we use:

``` cmake
find_package(raylib CONFIG 5.5 QUIET)
```

or

``` cmake
find_package(Catch2 CONFIG 3.8...<4.0 QUIET)    # newer than 3.8 but older than 4.0
```

to make sure the content is available.

This is the full example of how we use it:

```cmake
find_package(fmt CONFIG 11.0.0 QUIET)
if (NOT fmt_FOUND)
    message(STATUS "fmt could not be found or version is too old, downloading via FetchContent...")
    FetchContent_Declare(
    fmt
    GIT_REPOSITORY https://github.com/fmtlib/fmt.git
    GIT_TAG        11.2.0)
    FetchContent_MakeAvailable(fmt)
endif()
```

### Disable Build Example

Some content come with its own app or example, this might cause name conflict.
In order to prevent this, we use this to prevent the compiler from building the app or example.

``` cmake
set(BUILD_EXAMPLES OFF CACHE BOOL "" FORCE)
```

Note, this needs to come before *FetchContent_Declare*, otherwise it will fail to stop the compiler from building the examples.

## Reference

- [raylib](https://www.raylib.com/)
- [Aggregate and Explicit Initialization](https://en.cppreference.com/w/cpp/language/aggregate_initialization.html)
